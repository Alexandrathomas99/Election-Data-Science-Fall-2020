<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Presentation Ninja</title>
    <meta charset="utf-8" />
    <meta name="author" content="Yihui Xie" />
    <meta name="author" content="Garrick Aden-Buie" />
    <meta name="date" content="2020-09-06" />
    <link href="libs/tile-view/tile-view.css" rel="stylesheet" />
    <script src="libs/tile-view/tile-view.js"></script>
    <link href="libs/animate.css/animate.xaringan.css" rel="stylesheet" />
    <link href="libs/tachyons/tachyons.min.css" rel="stylesheet" />
    <link href="libs/panelset/panelset.css" rel="stylesheet" />
    <script src="libs/panelset/panelset.js"></script>
    <script src="libs/clipboard/clipboard.min.js"></script>
    <link href="libs/shareon/shareon.min.css" rel="stylesheet" />
    <script src="libs/shareon/shareon.min.js"></script>
    <link href="libs/xaringanExtra-shareagain/shareagain.css" rel="stylesheet" />
    <script src="libs/xaringanExtra-shareagain/shareagain.js"></script>
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Presentation Ninja
## ‚öîÔ∏è xaringan +<br/>üòé xaringanthemer
### Yihui Xie
### Garrick Aden-Buie
### 2020-09-06

---





class: center, middle
# Welcome! 

---
class: center, middle
--
# Y'all are gonna help me make my lunch.

---
# The challenge:

--
- You guys are going to break out into two groups. Each will have:

--
  - An instruction writer.

--
  - An instruction reader.

--
- You have five minutes to write me instructions for how to make a peanut butter jelly sandwich.

---
&lt;img src = "https://img.youtube.com/vi/LVPNXsc4wsQ/hqdefault.jpg"&gt;

---
class: center, middle

# Congratulations! You just wrote an algorithim!

--
.bg-washed-green.b--dark-green.ba.bw2.br3.shadow-5.ph4.mt5[
**Per Wikipedia:** Algorithims are simply "finite sequences of well-defined steps typically used to solve a problem or some class of problems."] 

???
In this case, the problem happened to be that I was gonna be hungry. But in data science, the problem is often how to make the data ready for later analysis and then how to do the analysis by itself. 

As y'all can see from the sandwiches, the emphasis is really on the "well-defined" part.


The algorithm was expressed in english, compiled and evaluated by me and my brain--but in this class we're gonna be using code. Specifically R code.

---
class: middle, center

# To understand coding in R, there's a concept we need to revisit.

--

`\(f(x)\)`

---

class: center, middle
&lt;img src="krabs.png" width="50%" style="display: block; margin: auto;" /&gt;
--
I promise, it's gonna be ok.

---
# Can't have "functions" without "fun"! (I'm so sorry)

- Normally when you see functions, it's often in the context of something like this:

--

  - `\(f(x) = x^2-1\)`
  - Say x is 2. Then `\(f(2) =2^2 - 1 = 3\)` 

- But we have to think **broader.**

--

- *Functions* are actually a set of steps that takes an inputted object and performs a transformation on it.
  - *transformations* are simply a sequence of pre-defined steps where actions are perfomed upon the input, resulting in an output.

---
# Objects can also be generalized.

--

- **Single numbers aren't the only thing that can be input into a function.**
--
  - This is what happens when you make a graph out of a mathematical equation.
  - You're (usually) passing all possible values of `\(x\)` into `\(f(x)\)` and plotting the outputted value.
  - Or at least all values within a set range. 

--

- **But you can also make functions for non-numeric objects.**
  - A function that takes "cucumbers" , "apples", and "bananas" and rearranges them alphabetically.
    - The list of fruit are an *object*; the function takes the object and then spits out a transformation.
--

  - Function that takes a matrix 	`\(\begin{pmatrix} 1 &amp; 2 &amp; 3 \\ 4 &amp; 5 &amp; 6 \end{pmatrix}\)` and halves all odd numbers.
    - The matrix as a whole is an *object*; the function works on the elements within the object and transforms them.

---
class: middle

.bg-washed-blue.b--dark-blue.ba.bw2.br3.shadow-5.ph4.mt5[
To understand programming in R, two slogans are helpful:

* Everything that exists is an object.
* Everything that happens is a function call.

.tr[
‚Äî John Chambers
]] 

---
class: center, middle

**When you do data science in R, your task is to use preexisting functions (and sometimes create your own!) in ways that take the desired objecs (i.e., "data") and transforms them so that they are usable and useful for later analyses.**

--
*In so doing, you define the steps that you want the data to go through---the order and scope of the transformations. It is very easy for things to go awry and for you to end up with something completely different than what you thought when you sat down and started. So you have to be conscious and deliberate in your steps, and in your coding, or else your analyses will be plagued by otherwise avoidable errors.*
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
